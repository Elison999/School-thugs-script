-- Rayfield Library
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
Name = "school thugs - brig hub - by darker9899",
LoadingTitle = "Loading...",
LoadingSubtitle = "by daker9899",
ConfigurationSaving = {
Enabled = true,
FolderName = nil,
FileName = "DetectorSpamConfig"
},
Discord = {
Enabled = false
},
KeySystem = false
})

-- Vari√°veis
local spamAtivo = false
local distanciaDetector = 13
local spamVelocidade = 50 -- porcentagem
local autoFollowAtivo = false
local botaoFlutuanteVisivel = false
local targetPlayer = nil
local distanciaToggleDetector = 10 -- Nova vari√°vel para dist√¢ncia do detector do toggle
local autoTeleportAtivo = false -- Toggle para auto teleport quando vida baixa
local teleportTargetPlayer = nil -- Player alvo para teleport
local estaTeleportando = false -- Estado atual do teleport
local godModeAtivo = false -- Toggle para god mode
local atacantePlayer = nil -- Player que deu dano
local teleportandoAtacante = false -- Estado se est√° teleportando para o atacante
local vidaAnterior = 100 -- Para detectar quando recebe dano
local killAuraAtivo = false -- Toggle para kill aura
local killAuraRange = 50 -- Alcance do kill aura
local killAuraTarget = nil -- Alvo atual do kill aura
local autoKillAuraAtivo = false -- Toggle para auto kill aura quando vida baixa
local killAuraAtivadoAuto = false -- Estado se o kill aura foi ativado automaticamente

-- Vari√°veis do Auto Anti-Hit
local autoAntiHitAtivo = false -- Toggle para auto anti-hit
local antiHitBarrier = nil -- Refer√™ncia para a barreira
local antiHitAtivado = false -- Estado se a barreira est√° ativa

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- GUI do bot√£o flutuante
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AutoFollowGUI"
screenGui.ResetOnSpawn = false -- Impede que suma quando morrer
screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local botaoFlutuante = Instance.new("TextButton")
botaoFlutuante.Name = "AutoFollowButton"
botaoFlutuante.Size = UDim2.new(0, 120, 0, 50)
botaoFlutuante.Position = UDim2.new(0, 50, 0, 200)
botaoFlutuante.BackgroundColor3 = Color3.fromRGB(255, 85, 85)
botaoFlutuante.Text = "Follow: OFF"
botaoFlutuante.TextColor3 = Color3.fromRGB(255, 255, 255)
botaoFlutuante.TextScaled = true
botaoFlutuante.Font = Enum.Font.SourceSansBold
botaoFlutuante.BorderSizePixel = 0
botaoFlutuante.Visible = false
botaoFlutuante.Parent = screenGui

-- Corner arredondado
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 10)
corner.Parent = botaoFlutuante

-- Sistema de arrastar
local dragging = false
local dragStart = nil
local startPos = nil

botaoFlutuante.InputBegan:Connect(function(input)
if input.UserInputType == Enum.UserInputType.MouseButton1 then
dragging = true
dragStart = input.Position
startPos = botaoFlutuante.Position
end
end)

UserInputService.InputChanged:Connect(function(input)
if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
local delta = input.Position - dragStart
botaoFlutuante.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end
end)

UserInputService.InputEnded:Connect(function(input)
if input.UserInputType == Enum.UserInputType.MouseButton1 then
dragging = false
end
end)

-- Toggle do bot√£o flutuante
botaoFlutuante.MouseButton1Click:Connect(function()
if not dragging then
autoFollowAtivo = not autoFollowAtivo
if autoFollowAtivo then
botaoFlutuante.Text = "auto fight: ON"
botaoFlutuante.BackgroundColor3 = Color3.fromRGB(85, 255, 85)
else
botaoFlutuante.Text = "auto fight: OFF"
botaoFlutuante.BackgroundColor3 = Color3.fromRGB(255, 85, 85)
targetPlayer = nil
end
end
end)

-- Fun√ß√£o para criar a barreira anti-hit
local function criarBarreiraAntiHit()
if antiHitBarrier then
antiHitBarrier:Destroy()
end

local player = game.Players.LocalPlayer
local character = player.Character
if not character or not character:FindFirstChild("HumanoidRootPart") then return end

-- Criar a barreira invis√≠vel
antiHitBarrier = Instance.new("Part")
antiHitBarrier.Name = "AntiHitBarrier"
antiHitBarrier.Size = Vector3.new(20, 20, 20)
antiHitBarrier.Material = Enum.Material.ForceField
antiHitBarrier.Color = Color3.fromRGB(255, 0, 0)
antiHitBarrier.Transparency = 1
antiHitBarrier.CanCollide = true
antiHitBarrier.Anchored = true
antiHitBarrier.Parent = workspace

-- Posicionar a barreira no jogador
local rootPart = character.HumanoidRootPart
antiHitBarrier.CFrame = rootPart.CFrame
end

-- Fun√ß√£o para remover a barreira anti-hit
local function removerBarreiraAntiHit()
if antiHitBarrier then
antiHitBarrier:Destroy()
antiHitBarrier = nil
end
antiHitAtivado = false
end

-- Fun√ß√£o para verificar vida e controlar anti-hit
local function verificarVidaEAntiHit()
if not autoAntiHitAtivo then return end

local player = game.Players.LocalPlayer
local character = player.Character
if not character then return end

local humanoid = character:FindFirstChild("Humanoid")
if not humanoid then return end

local vidaAtual = humanoid.Health

-- Se vida <= 15 e anti-hit n√£o est√° ativo, criar barreira
if vidaAtual <= 15 and not antiHitAtivado then
criarBarreiraAntiHit()
antiHitAtivado = true
end

-- Se vida > 15 e anti-hit est√° ativo, remover barreira
if vidaAtual > 15 and antiHitAtivado then
removerBarreiraAntiHit()
end
end

-- Fun√ß√£o para atualizar posi√ß√£o da barreira
local function atualizarPosicaoBarreira()
if not antiHitBarrier or not antiHitAtivado then return end

local player = game.Players.LocalPlayer
local character = player.Character
if not character or not character:FindFirstChild("HumanoidRootPart") then return end

-- Atualizar posi√ß√£o da barreira para seguir o jogador
antiHitBarrier.CFrame = character.HumanoidRootPart.CFrame
end

-- Fun√ß√£o para recriar barreiras quando jogadores morrem/renascem
local function monitorarJogadores()
-- Conectar eventos de morte/renascimento para todos os jogadores
for _, player in ipairs(game.Players:GetPlayers()) do
if player ~= game.Players.LocalPlayer then
player.CharacterAdded:Connect(function()
if autoAntiHitAtivo and antiHitAtivado then
-- Recriar a barreira quando qualquer jogador renascer
task.wait(1)
if antiHitAtivado then
criarBarreiraAntiHit()
end
end
end)
end
end

-- Monitorar novos jogadores que entram
game.Players.PlayerAdded:Connect(function(player)
player.CharacterAdded:Connect(function()
if autoAntiHitAtivo and antiHitAtivado then
task.wait(1)
if antiHitAtivado then
criarBarreiraAntiHit()
end
end
end)
end)
end

-- Fun√ß√£o de spam com delay entre c√≥digos
local function enviarSpam()
local evento = game:GetService("ReplicatedStorage").MainEvents.BLOCKEVENT
local argsTrue = {[1] = true}
local argsFalse = {[1] = false}

evento:FireServer(unpack(argsTrue))  
task.wait(math.clamp((1 - (spamVelocidade / 9999999999999999999)) / 1, 0.001, 0.001)) -- delay entre c√≥digos  
evento:FireServer(unpack(argsFalse))

end

-- Nova fun√ß√£o para o PUNCHEVENT
local function enviarPunch()
local player = game.Players.LocalPlayer
local character = player.Character
if character and character:FindFirstChild("UpperTorso") then
local args = {
[1] = 1,
[2] = character,
[3] = 50,
[4] = character.UpperTorso
}
game:GetService("ReplicatedStorage").MainEvents.PUNCHEVENT:FireServer(unpack(args))
end
end

-- Fun√ß√£o de seguimento autom√°tico
local function seguirPlayer()
if not autoFollowAtivo or not targetPlayer or not targetPlayer.Character then
return
end

local player = Players.LocalPlayer  
local character = player.Character  
  
if character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("Humanoid") then  
    local targetCharacter = targetPlayer.Character  
    if targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart") then  
        local humanoid = character.Humanoid  
        local targetPosition = targetCharacter.HumanoidRootPart.Position  
        humanoid:MoveTo(targetPosition)  
          
        -- Fazer o personagem pular (s√≥ se estiver no ch√£o)  
        if humanoid.FloorMaterial ~= Enum.Material.Air then  
            humanoid.Jump = true  
        end  
    end  
end

end

-- Fun√ß√£o principal
local function iniciarDetector()
task.spawn(function()
while task.wait() do
if spamAtivo then
local player = game.Players.LocalPlayer
local char = player.Character
if char and char:FindFirstChild("HumanoidRootPart") then
for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
local dist = (char.HumanoidRootPart.Position - otherPlayer.Character.HumanoidRootPart.Position).Magnitude
if dist <= distanciaDetector then
-- Define o target para seguimento se o auto follow estiver ativo
if autoFollowAtivo and not targetPlayer then
targetPlayer = otherPlayer
end
enviarSpam()
task.wait(math.clamp((1 - (spamVelocidade / 9999999999999999999)), 0.001, 1))
end
end
end
end
end
end
end)
end

-- Fun√ß√£o para verificar vida e controlar teleport
local function verificarVidaETeleport()
local player = game.Players.LocalPlayer
local character = player.Character
if not autoTeleportAtivo or not character then return end

local humanoid = character:FindFirstChild("Humanoid")
if not humanoid then return end

local vidaAtual = humanoid.Health

-- Se vida <= 10 e n√£o est√° teleportando, come√ßar a teleportar
if vidaAtual <= 10 and not estaTeleportando then
estaTeleportando = true
-- Encontrar um player alvo se n√£o tiver um
if not teleportTargetPlayer then
for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
teleportTargetPlayer = otherPlayer
break
end
end
end
end

-- Se vida >= 20 e est√° teleportando, parar de teleportar
if vidaAtual >= 20 and estaTeleportando then
estaTeleportando = false
teleportTargetPlayer = nil
end
end

-- Fun√ß√£o para detectar dano e encontrar atacante
local function detectarDanoEAtacante()
if not godModeAtivo then return end

local player = game.Players.LocalPlayer
local character = player.Character
if not character then return end

local humanoid = character:FindFirstChild("Humanoid")
if not humanoid then return end

local vidaAtual = humanoid.Health

-- Se recebeu dano (vida diminuiu)
if vidaAtual < vidaAnterior and vidaAtual > 0 then
-- Procurar player mais pr√≥ximo dentro de 13 studs (prov√°vel atacante)
local playerMaisProximo = nil
local menorDistancia = 13

if character:FindFirstChild("HumanoidRootPart") then
for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
local dist = (character.HumanoidRootPart.Position - otherPlayer.Character.HumanoidRootPart.Position).Magnitude
if dist <= menorDistancia then
menorDistancia = dist
playerMaisProximo = otherPlayer
end
end
end

-- Se encontrou um atacante, come√ßar a teleportar
if playerMaisProximo then
atacantePlayer = playerMaisProximo
teleportandoAtacante = true
end
end
end

vidaAnterior = vidaAtual
end

-- Fun√ß√£o para verificar se o atacante est√° deitado/ragdoll
local function atacanteEstaDeitado()
if not atacantePlayer or not atacantePlayer.Character then return false end

local atacanteCharacter = atacantePlayer.Character
local humanoid = atacanteCharacter:FindFirstChildOfClass("Humanoid")
if not humanoid then return false end

-- Verifica se est√° em estado de ragdoll ou deitado
local stateType = humanoid:GetState()
return stateType == Enum.HumanoidStateType.Ragdoll or 
       stateType == Enum.HumanoidStateType.FallingDown or
       stateType == Enum.HumanoidStateType.Flying or
       stateType == Enum.HumanoidStateType.Freefall or
       humanoid.PlatformStand == true or
       humanoid.Sit == true
end

-- Fun√ß√£o para teleportar atr√°s do atacante
local function teleportarAtrasDoAtacante()
if not teleportandoAtacante or not atacantePlayer then return end

local player = game.Players.LocalPlayer
local character = player.Character
if not character or not character:FindFirstChild("HumanoidRootPart") then return end

local atacanteCharacter = atacantePlayer.Character
if not atacanteCharacter or not atacanteCharacter:FindFirstChild("HumanoidRootPart") then
-- Se o atacante n√£o existe mais, parar de teleportar
teleportandoAtacante = false
atacantePlayer = nil
return
end

-- Se o atacante est√° deitado/ragdoll, n√£o teleportar
if atacanteEstaDeitado() then
return
end

-- Calcular posi√ß√£o atr√°s do atacante (dist√¢ncia 2)
local atacanteRoot = atacanteCharacter.HumanoidRootPart
local atacantePosition = atacanteRoot.Position
local atacanteLookVector = atacanteRoot.CFrame.LookVector
local posicaoAtras = atacantePosition - (atacanteLookVector * 3)

-- Teleportar
character.HumanoidRootPart.CFrame = CFrame.new(posicaoAtras, atacantePosition)
end

-- Fun√ß√£o para encontrar o alvo mais pr√≥ximo para Kill Aura
local function encontrarAlvoKillAura()
if not killAuraAtivo then return nil end

local player = game.Players.LocalPlayer
local character = player.Character
if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end

local localroot = character.HumanoidRootPart
local range = killAuraRange
local target = nil

for _, v in pairs(game.Players:GetPlayers()) do
if v ~= player and v.Character and not v.Character:FindFirstChildWhichIsA("ForceField") then
local JN = v.Character:FindFirstChild("HumanoidRootPart")
local JNR = v.Character:FindFirstChildOfClass("Humanoid")
if JN and JNR and JNR.Health > 3 then
local dist = (localroot.Position - JN.Position).magnitude
if dist < range then
range = dist
target = v.Character
end
end
end
end

return target
end

-- Fun√ß√£o para verificar vida e controlar auto kill aura
local function verificarVidaEAutoKillAura()
if not autoKillAuraAtivo then return end

local player = game.Players.LocalPlayer
local character = player.Character
if not character then return end

local humanoid = character:FindFirstChild("Humanoid")
if not humanoid then return end

local vidaAtual = humanoid.Health

-- Se vida <= 40 e kill aura n√£o est√° ativo, ativar automaticamente
if vidaAtual <= 40 and not killAuraAtivo then
killAuraAtivo = true
killAuraAtivadoAuto = true
end

-- Se vida > 40 e kill aura foi ativado automaticamente, desativar
if vidaAtual > 40 and killAuraAtivadoAuto then
killAuraAtivo = false
killAuraAtivadoAuto = false
killAuraTarget = nil
end
end
local function executarKillAura()
if not killAuraAtivo then return end

killAuraTarget = encontrarAlvoKillAura()

if killAuraTarget and killAuraTarget:FindFirstChild("UpperTorso") then
local vroot = killAuraTarget:FindFirstChild("UpperTorso")
local args = {
[1] = 1,
[2] = killAuraTarget,
[3] = 50,
[4] = vroot
}

game:GetService("ReplicatedStorage").MainEvents.PUNCHEVENT:FireServer(unpack(args))
end
end
local function resetarGodMode()
atacantePlayer = nil
teleportandoAtacante = false
local player = game.Players.LocalPlayer
local character = player.Character
if character then
local humanoid = character:FindFirstChild("Humanoid")
if humanoid then
vidaAnterior = humanoid.Health
end
end
end
local function teleportarAtrasDoPlayer()
if not estaTeleportando or not teleportTargetPlayer then return end

local player = game.Players.LocalPlayer
local character = player.Character
if not character or not character:FindFirstChild("HumanoidRootPart") then return end

local targetCharacter = teleportTargetPlayer.Character
if not targetCharacter or not targetCharacter:FindFirstChild("HumanoidRootPart") then
-- Se o target n√£o existe mais, procurar outro
teleportTargetPlayer = nil
for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
teleportTargetPlayer = otherPlayer
targetCharacter = otherPlayer.Character
break
end
end
if not targetCharacter then return end
end

-- Calcular posi√ß√£o atr√°s do target (dist√¢ncia 13)
local targetRoot = targetCharacter.HumanoidRootPart
local targetPosition = targetRoot.Position
local targetLookVector = targetRoot.CFrame.LookVector
local posicaoAtras = targetPosition - (targetLookVector * 13)

-- Teleportar
character.HumanoidRootPart.CFrame = CFrame.new(posicaoAtras, targetPosition)
end
local function detectorTogglePunch()
task.spawn(function()
while task.wait() do
if autoFollowAtivo then
local player = game.Players.LocalPlayer
local char = player.Character
if char and char:FindFirstChild("HumanoidRootPart") then
for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
local dist = (char.HumanoidRootPart.Position - otherPlayer.Character.HumanoidRootPart.Position).Magnitude
if dist <= distanciaToggleDetector then
enviarPunch()
task.wait(0.1) -- Pequeno delay entre punches
end
end
end
end
end
end
end)
end

-- Fun√ß√£o de spam de clicks e ataques
local function spamClicks()
if autoFollowAtivo then
VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
task.wait(0.01)
VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
end
end

-- Fun√ß√£o de spam de ataques e block quando detectar player
local function spamAtaques()
if autoFollowAtivo and targetPlayer then
local player = Players.LocalPlayer
local char = player.Character
if char and char:FindFirstChild("HumanoidRootPart") and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
local dist = (char.HumanoidRootPart.Position - targetPlayer.Character.HumanoidRootPart.Position).Magnitude
if dist <= distanciaDetector then
-- Lan√ßar os dois ataques
game:GetService("ReplicatedStorage").MainEvents.SUPLEXEVENT:FireServer()
task.wait(0.1)
game:GetService("ReplicatedStorage").MainEvents.HEAVYHIT:FireServer()
end
end
end
end

-- Fun√ß√£o de spam de block quando detectar player no auto follow
local function spamBlockAutoFollow()
if autoFollowAtivo and targetPlayer then
local player = Players.LocalPlayer
local char = player.Character
if char and char:FindFirstChild("HumanoidRootPart") and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
local dist = (char.HumanoidRootPart.Position - targetPlayer.Character.HumanoidRootPart.Position).Magnitude
if dist <= distanciaDetector then
-- Spam do block event
local evento = game:GetService("ReplicatedStorage").MainEvents.BLOCKEVENT
local argsTrue = {[1] = true}
local argsFalse = {[1] = false}

evento:FireServer(unpack(argsTrue))  
task.wait(0.1)
evento:FireServer(unpack(argsFalse))
end
end
end
end

-- Loop de seguimento, spam de clicks, ataques, block, teleport, god mode, kill aura, auto kill aura e anti-hit
RunService.Heartbeat:Connect(function()
if autoFollowAtivo then
seguirPlayer()
spamClicks()
spamAtaques()
spamBlockAutoFollow() -- Nova fun√ß√£o para spam de block no auto follow
end

-- Verificar vida e controlar teleport
if autoTeleportAtivo then
verificarVidaETeleport()
if estaTeleportando then
teleportarAtrasDoPlayer()
end
end

-- God Mode: detectar dano e teleportar
if godModeAtivo then
detectarDanoEAtacante()
if teleportandoAtacante then
teleportarAtrasDoAtacante()
end
end

-- Auto Kill Aura por vida
if autoKillAuraAtivo then
verificarVidaEAutoKillAura()
end

-- Kill Aura
if killAuraAtivo then
executarKillAura()
end

-- Auto Anti-Hit
if autoAntiHitAtivo then
verificarVidaEAntiHit()
atualizarPosicaoBarreira()
end
end)

-- Sempre reinicia quando morrer
local function monitorarRespawn()
local player = game.Players.LocalPlayer
player.CharacterAdded:Connect(function()
task.wait(1)
iniciarDetector()
detectorTogglePunch() -- Inicializar o novo detector
targetPlayer = nil -- Reset target quando respawnar
teleportTargetPlayer = nil -- Reset teleport target quando respawnar
estaTeleportando = false -- Reset estado do teleport
resetarGodMode() -- Reset god mode quando respawnar
killAuraTarget = nil -- Reset kill aura target quando respawnar
killAuraAtivadoAuto = false -- Reset auto kill aura quando respawnar
-- Reset anti-hit quando respawnar
removerBarreiraAntiHit()
end)
end

-- Aba do Rayfield
local TabSp = Window:CreateTab("Combatüëä", 4483362458)

TabSp:CreateToggle({
Name = "Auto Anti-Hit (heath ‚â§ 15)",
CurrentValue = false,
Flag = "ToggleAutoAntiHit",
Callback = function(Value)
autoAntiHitAtivo = Value
if not Value then
removerBarreiraAntiHit()
end
end
})

TabSp:CreateToggle({
Name = "Kill Aura",
CurrentValue = false,
Flag = "ToggleKillAura",
Callback = function(Value)
killAuraAtivo = Value
if not Value then
killAuraTarget = nil
end
end
})

TabSp:CreateToggle({
Name = "God Mode (anti-damage)",
CurrentValue = false,
Flag = "ToggleGodMode",
Callback = function(Value)
godModeAtivo = Value
if not Value then
resetarGodMode()
else
-- Inicializar vida anterior quando ativar
local player = game.Players.LocalPlayer
local character = player.Character
if character then
local humanoid = character:FindFirstChild("Humanoid")
if humanoid then
vidaAnterior = humanoid.Health
end
end
end
end
})

TabSp:CreateToggle({
Name = "auto block",
CurrentValue = false,
Flag = "ToggleSpam",
Callback = function(Value)
spamAtivo = Value
end
})

TabSp:CreateToggle({
Name = "Show toggle auto fight",
CurrentValue = false,
Flag = "ToggleBotaoFollow",
Callback = function(Value)
botaoFlutuanteVisivel = Value
botaoFlutuante.Visible = Value
if not Value then
autoFollowAtivo = false
targetPlayer = nil
botaoFlutuante.Text = "Follow: OFF"
botaoFlutuante.BackgroundColor3 = Color3.fromRGB(255, 85, 85)
end
end
})

TabSp:CreateToggle({
Name = "Auto Teleport (Low Life)",
CurrentValue = false,
Flag = "ToggleAutoTeleport",
Callback = function(Value)
autoTeleportAtivo = Value
if not Value then
estaTeleportando = false
teleportTargetPlayer = nil
end
end
})

TabSp:CreateSlider({
Name = "Kill Aura Range",
Range = {10, 100},
Increment = 5,
Suffix = " studs",
CurrentValue = 50,
Flag = "KillAuraRange",
Callback = function(Value)
killAuraRange = Value
end
})

TabSp:CreateSlider({
Name = "auto fight distance",
Range = {5, 50},
Increment = 1,
Suffix = " studs",
CurrentValue = 13,
Flag = "DistanciaDetector",
Callback = function(Value)
distanciaDetector = Value
end
})

TabSp:CreateSlider({
Name = "speed auto block",
Range = {1, 9999999999999999999},
Increment = 1,
Suffix = "%",
CurrentValue = 50,
Flag = "VelocidadeSpam",
Callback = function(Value)
spamVelocidade = Value
end
})

TabSp:CreateSlider({
Name = "Distance Toggle Detector (Punch)",
Range = {5, 25},
Increment = 1,
Suffix = " studs",
CurrentValue = 10,
Flag = "DistanciaToggleDetector",
Callback = function(Value)
distanciaToggleDetector = Value
end
})

-- Inicializa√ß√£o
monitorarRespawn()
monitorarJogadores() -- Inicializar monitoramento de jogadores para anti-hit
iniciarDetector()
detectorTogglePunch() -- Inicializar o



local Tabv2 = Window:CreateTab("v2", 4483362458) -- Title, Image

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

local hitboxParts = {}
local antiHitEnabled = false

local function createHitboxForPlayer(player)
    if player == LocalPlayer then return end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    
    local part = Instance.new("Part")
    part.Size = Vector3.new(10, 10, 10) -- tamanho do hitbox
    part.Transparency = 1 -- invis√≠vel
    part.Anchored = false
    part.CanCollide = true
    part.Massless = true
    part.Parent = player.Character
    part.CFrame = player.Character.HumanoidRootPart.CFrame
    
    local weld = Instance.new("WeldConstraint")
    weld.Part0 = part
    weld.Part1 = player.Character.HumanoidRootPart
    weld.Parent = part
    
    hitboxParts[player] = part
end

local function removeHitboxForPlayer(player)
    if hitboxParts[player] then
        hitboxParts[player]:Destroy()
        hitboxParts[player] = nil
    end
end

local function updateHitboxes()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                if LocalPlayer.Character.Humanoid.Health == 15 then
                    if not hitboxParts[player] then
                        createHitboxForPlayer(player)
                    end
                else
                    removeHitboxForPlayer(player)
                end
            end
        end
    end
end

-- Atualizar quando players entrarem/sair
Players.PlayerAdded:Connect(function(player)
    if antiHitEnabled then
        updateHitboxes()
    end
end)

Players.PlayerRemoving:Connect(function(player)
    removeHitboxForPlayer(player)
end)

-- Loop para verificar vida e atualizar hitbox
RunService.Heartbeat:Connect(function()
    if antiHitEnabled then
        updateHitboxes()
    end
end)

-- Toggle Rayfield
local Toggle = Tabv2:CreateToggle({
    Name = "Anti Hit (vida = 15)",
    CurrentValue = false,
    Flag = "AntiHitToggle",
    Callback = function(Value)
        antiHitEnabled = Value
        if not Value then
            for _, part in pairs(hitboxParts) do
                part:Destroy()
            end
            hitboxParts = {}
        else
            updateHitboxes()
        end
    end,
})

local Tab = Window:CreateTab("Spam Block", 4483362458)
local Section = Tab:CreateSection("Configura√ß√µes")

-- Vari√°veis de controle
local spamEnabled = false
local distanceDetection = false
local detectionDistance = 13
local spamConnection
local detectionConnection
local spamMultiplier = 1

-- Fun√ß√£o para executar o c√≥digo de block
local function executeBlockCode(state)
    local args = {
        [1] = state
    }
    game:GetService("ReplicatedStorage").MainEvents.BLOCKEVENT:FireServer(unpack(args))
end

-- Fun√ß√£o para detectar players pr√≥ximos
local function detectNearbyPlayers()
    local player = game.Players.LocalPlayer
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local playerPosition = player.Character.HumanoidRootPart.Position
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (otherPlayer.Character.HumanoidRootPart.Position - playerPosition).Magnitude
            if distance <= detectionDistance then
                return true
            end
        end
    end
    return false
end

-- Fun√ß√£o principal de spam
local function startSpamLoop()
    if spamConnection then
        spamConnection:Disconnect()
    end
    
    spamConnection = game:GetService("RunService").Heartbeat:Connect(function()
        if spamEnabled then
            if distanceDetection then
                if detectNearbyPlayers() then
                    -- Multiplica o spam quando detecta players pr√≥ximos
                    for i = 5, spamMultiplier do
                        executeBlockCode(true)
                        wait(0.01) -- Pequeno delay entre execu√ß√µes
                        executeBlockCode(false)
                        wait(0.01)
                    end
                end
            else
                -- Spam normal sem detec√ß√£o
                for i = 1, spamMultiplier do
                    executeBlockCode(true)
                    wait(0.01)
                    executeBlockCode(false)
                    wait(0.01)
                end
            end
        end
    end)
end

-- Toggle principal do spam
local SpamToggle = Tab:CreateToggle({
   Name = "auto spam block",
   CurrentValue = false,
   Flag = "SpamToggle",
   Callback = function(Value)
       spamEnabled = Value
       if Value then
           print("Spam Block ativado!")
           startSpamLoop()
       else
           print("Spam Block desativado!")
           if spamConnection then
               spamConnection:Disconnect()
           end
       end
   end,
})

-- Toggle do detector de dist√¢ncia
local DistanceToggle = Tab:CreateToggle({
   Name = "spam multiple",
   CurrentValue = false,
   Flag = "DistanceToggle",
   Callback = function(Value)
       distanceDetection = Value
       if Value then
           print("Detector de dist√¢ncia ativado! Dist√¢ncia: " .. detectionDistance)
       else
           print("Detector de dist√¢ncia desativado!")
       end
   end,
})

-- Slider para ajustar a dist√¢ncia de detec√ß√£o
local DistanceSlider = Tab:CreateSlider({
   Name = "auto spam block dist√¢nce",
   Range = {1, 50},
   Increment = 1,
   Suffix = " studs",
   CurrentValue = 13,
   Flag = "DistanceSlider",
   Callback = function(Value)
       detectionDistance = Value
       print("Dist√¢ncia de detec√ß√£o alterada para: " .. Value)
   end,
})

-- Slider para multiplicador de spam
local MultiplierSlider = Tab:CreateSlider({
   Name = "spam multiplicator",
   Range = {1, 10},
   Increment = 1,
   Suffix = "x",
   CurrentValue = 1,
   Flag = "MultiplierSlider",
   Callback = function(Value)
       spamMultiplier = Value
       print("Multiplicador de spam alterado para: " .. Value .. "x")
   end,
})

-- Se√ß√£o de informa√ß√µes
local InfoSection = Tab:CreateSection("Informa√ß√µes")

local InfoParagraph = Tab:CreateParagraph({
   Title = "Como usar:",
   Content = "1. Ative o 'Spam Block' para come√ßar o spam\n2. Ative o 'Detector de Dist√¢ncia' para s√≥ fazer spam quando houver players pr√≥ximos\n3. Ajuste a dist√¢ncia e multiplicador conforme necess√°rio\n4. O sistema ir√° executar automaticamente os c√≥digos true/false quando detectar players"
})

-- Bot√£o para teste manual
local TestButton = Tab:CreateButton({
   Name = "Teste Manual (True/False)",
   Callback = function()
       executeBlockCode(true)
       wait(0.3)
       executeBlockCode(false)
       print("Teste executado: True -> False")
   end,
})

-- Limpeza quando o script for fechado
game.Players.LocalPlayer.AncestryChanged:Connect(function()
    if spamConnection then
        spamConnection:Disconnect()
    end
    if detectionConnection then
        detectionConnection:Disconnect()
    end
end)